#!/bin/bash (source-only)

[[ -z ${_buildFunctionsIncluded:-} ]] || exit
_buildFunctionsIncluded=true

Build_Make () # collection recipe-token
{
    NeverInChroot

    _build_Enter "$1" "$2"

    local marks="$Current_Root/.marks"
    local buildMarker="$marks/build-$Recipe_Name-$Recipe_Version"
    local harvestMarker="$marks/harvest-$Recipe_Name-$Recipe_Version"
    local rolloutMarker="$marks/rollout-$Recipe_Name-$Recipe_Version"

    if [[ "new" == "${3-}" ]]; then
        RemoveDir $marks
    fi

    if [[ "break" == "${3-}" ]]; then
        _build_Break
        return
    fi

    if [[ ! -f $buildMarker || "$Recipe_File" -nt "$buildMarker" ]]; then
        RemoveFile $buildMarker $harvestMarker $rolloutMarker
        _build_Build
        Touch $buildMarker
    fi

    if [[ ! -f $harvestMarker ]]; then
        _build_Harvest
        Touch $harvestMarker
    fi

    if [[ "done" == "${3-}" ]]; then
        if [[ ! -f $rolloutMarker || $harvestMarker -nt $rolloutMarker ]]; then
            _harvest_Rollout
            Touch $rolloutMarker
        fi
    fi
}

Build_Build () # collection recipe
{
    NeverInChroot

    _build_Enter "$@"
    _build_Build
}

Build_Setup () # collection recipe
{
    NeverInChroot

    _build_Enter "$@"
    _build_EnsureBuild
}

Build_Shell () # collection recipe
{
    NeverInChroot

    _build_Enter "$@"
    _build_CleanBuild
    _build_EnsureBuild
    _build_MakeRootFs
    _build_ExecInChroot
}

Build_Break ()
{
    OnlyInChroot

    _build_Enter "$@"
    _build_EnsureBuild

    Header "BREAK $Current_Collection / $Recipe_Title"

    Pushd "$Box_Build"
    _build_EnterTop && bash -l
    Popd
}

Build_Compile ()
{
    OnlyInChroot

    _build_Enter "$@"
    _build_EnsureBuild

    Header "BUILD $Current_Collection / $Recipe_Title"

    _build_RecipePrepare
    _build_RecipeBuild
}

_build_Break ()
{
    _build_CleanBuild
    _build_EnsureBuild
    _build_ProvideSupplies
    _build_MakeRootFs
    _build_ExecInChroot "pogo break $Current_Collection $Recipe_Token"
}

_build_Build ()
{
    _build_CleanBuild
    _build_EnsureBuild
    _build_ProvideSupplies
    _build_MakeRootFs
    _build_ExecInChroot "pogo compile $Current_Collection $Recipe_Token"
    _build_RecipeCleanup
}

_build_Enter () # build name
{
    EnsurePogoEnvironment

    [[ -n "${1-}" ]] || Fatal "build name must be given"
    local collection="${1^}"
    local name
    if ! ListContains "$collection" "${Build_Collections[@]}"; then
        Fatal "build name '$collection' is not in (${Build_Collections[@]})"
    fi
    
    Current_Collection=$collection
    name="${collection}_Root"
    Current_Root=${!name}
    name="${collection}_Store"
    Current_Store=${!name}
    name="${collection}_Build"
    Current_Build=${!name}

    #if [[ -n "{verbose}" ]]; then
    #    declare -p Current_Collection
    #    declare -p Current_Root
    #    declare -p Current_Store
    #    declare -p Current_Build
    #fi

    if [[ -n "${2-}" ]]; then
        RecipeSource "${2}"
        Box_Top="$Current_Build/$Recipe_Tag"
        Store_Top="$Current_Store/$Recipe_Tag"
    else
        Box_Top="$Current_Build/SHELL"
        Store_Top="$Current_Store/SHELL"
    fi

    Box_Root=$Box_Top/Root
    Box_Changes=$Box_Top/Changes
    Box_Work=$Box_Top/Work
    Box_Merged=$Box_Top/Merged
    Box_Build=$Box_Top/Build
    Store_Logs=$Store_Top/Logs
    Store_FilesBom="$Store_Top/Bom"
    Store_FilesFiles="$Store_Top/Files.tar.xz"
    Store_Files=("$Store_FilesBom" "$Store_FilesFiles")

    _build_EnsureCollection

    #if [[ -n "{verbose}" ]]; then
    #    declare -p Box_Top
    #    declare -p Box_Root
    #    declare -p Box_Changes
    #    declare -p Box_Work
    #    declare -p Box_Merged
    #    declare -p Box_Build
    #    declare -p Store_Top
    #    declare -p Store_Logs
    #fi
}

_build_EnsureCollection ()
{
    local directories=(
        "$Current_Root"
        "$Current_Store"
        "$Current_Build"
    )
    MakeDir "${directories[@]}"
}

_build_CleanCollection ()
{
    RemoveDir "$Current_Root"
    RemoveDir "$Current_Store"
    RemoveDir "$Current_Build"
}

_build_EnsureBuild ()
{
    local directories=(
        "$Box_Top"
        "$Box_Root"
        "$Box_Changes"
        "$Box_Work"
        "$Box_Merged"
        "$Box_Build"
        "$Store_Top"
        "$Store_Logs"
    )
    MakeDir "${directories[@]}"
}

_build_CleanBuild ()
{
    RemoveDir "$Box_Top"
    rm ${verbose} --force "${Store_Files[@]}"
}

_build_ProvideSupplies ()
{
    local supply
    if [[ "${Recipe_Supplies[0]}" != "none" ]]; then
        for supply in "${Recipe_Supplies[@]}"; do
            _build_ProvideSupply $supply
        done
    fi
}

_build_wget ()
{
    local supply="$1"

    already=$(basename $supply)
    [[ -f $PogoArchives/$already ]] && return 0
    if ! wget ${supply} --continue --directory-prefix=$PogoDownloads; then
        if ! wget ${supply} --no-check-certificate --continue --directory-prefix=$PogoDownloads; then
            Fatal "download of '$supply' failed"
        fi
    fi
    mv ${verbose} --force $PogoDownloads/$already $PogoArchives/$already
}

_build_ProvideSupply ()
{
    local supply="$1"
    local basename=$(basename "$supply")

    if [[ ! -f $PogoArchives/$basename ]]; then
        echo "must download '$supply'"
        _build_wget $supply
    fi

    [[ -f $PogoArchives/$basename ]] || Fatal "local archive '$basename' for supply '$supply' missing"

    local stem

    case $basename in
        *.tar.?? | *.tar.???)
            stem=${basename%.tar.*}
            _buildExtractSupply $basename $stem
            ln $verbose --symbolic --relative --force --no-target-directory $PogoSources/$stem $Box_Build/$stem
        ;;
        *.tgz)
            stem=${basename%.tgz}
            _buildExtractSupply $basename $stem
            echo ln $verbose --symbolic --relative --force --no-target-directory $PogoSources/$stem $Box_Build/$stem
            ln $verbose --symbolic --relative --force --no-target-directory $PogoSources/$stem $Box_Build/$stem
        ;;
        *.patch | *.xml)
            cp $verbose --force $PogoArchives/$basename $PogoSources/$basename
        ;;
        *)
            Fatal "can't provide supply '$supply'"
        ;;
    esac
}

_buildExtractSupply ()
{
    local basename=$1
    local stem=$2
    local archive=$PogoArchives/$basename
    local extract=$PogoSources/$stem

    local tmpExtract=$extract.tmp

    RemoveDir $tmpExtract

    [[ -d $extract ]] && return

    mkdir $verbose --parents $tmpExtract

    Pushd $tmpExtract
    tar xvf $archive
    Popd

    if [[ $(ls -1 $tmpExtract | wc -l) == 1 ]]; then
        mv $verbose $tmpExtract/* $extract
        rmdir $verbose $tmpExtract
    else
        mv $verbose $tmpExtract $extract
    fi
}

_build_RecipePrepare ()
{
    Pushd "$Box_Build"
    _build_EnterTop && Recipe_ExecIfExists "Prepare"
    Popd
}

_build_RecipeBuild ()
{
    Pushd "$Box_Build"
    _build_EnterBuildIn && Recipe_ExecIfExists "Build"
    Popd
}

_build_RecipeCleanup ()
{
    Pushd "$Box_Changes"
    Recipe_ExecIfExists "Cleanup"
    Popd
}

_build_EnterTop ()
{
    if [[ "${Recipe_Supplies[0]}" == "none" ]]; then
        cd $Box_Build
    else
        local supply=${Recipe_Supplies[0]}
        local basename=$(basename $supply)
        local stem="$basename"
        local stem=${stem%.tar.*}
        local stem=${stem%.tgz}

        #echo "=================================>>>"
        #declare -p supply
        #declare -p basename
        #declare -p stem
        #echo "<<<================================="
        cd $Box_Build/$stem
    fi
}

_build_EnterBuildIn ()
{
    _build_EnterTop
    if [[ -n "$Recipe_BuildIn" ]]; then
        MakeDir ./$Recipe_BuildIn
        cd $Recipe_BuildIn
    fi
}

_build_MakeRootFs ()
{
    Make${Current_Collection}Rootfs
}

_build_ExecInChroot ()
{
    ExecIn${Current_Collection}Chroot "$@"
}

RootMakeDir ()
{
    local mode="--mode=$1"
    shift 1
    while (( $# > 0 )); do
        local dir="$Box_Root/$1"
        shift
        mkdir "$verbose" --parents "$mode" "$dir"
    done
}

RootSymLink ()
{
    local link="$Box_Root/$1"
    local target="$2"
    
    ln "$verbose" --symbolic "$target" "$link"
}

_chroot_MountOverlay ()
{
    local lowerdir="$1"
    local options="lowerdir=$lowerdir,upperdir=$Box_Changes,workdir=$Box_Work"
    mount $verbose --types overlay overlay --options "$options" "$Box_Merged"
}

_chroot_MountCommons ()
{
    local merged="$Box_Merged"

    mount $verbose --bind /LiFo $merged/LiFo
    mount $verbose --bind /root $merged/root
    mount $verbose --rbind /dev $merged/dev
    mount $verbose --rbind /sys $merged/sys
    mount $verbose --rbind /proc $merged/proc
    mount $verbose --bind /etc/hostname $merged/etc/hostname
    mount $verbose --bind /etc/hosts $merged/etc/hosts
    mount $verbose --bind /etc/resolv.conf $merged/etc/resolv.conf
}

_chroot_exec ()
{
    if [[ -z "${2-}" ]]; then
        env $1 chroot $Box_Merged /bin/bash -l
    else
        env $1 chroot $Box_Merged /bin/bash -l -c "$2"
    fi
}

_chroot_exec2 ()
(   # execute in subshell

    local lowerdir="$1"
    local env="$2"
    local command="${3-}"

    trap 'BuildUnmount || true' EXIT

    _chroot_MountOverlay "$lowerdir"
    _chroot_MountCommons

    if [[ -z "$command" ]]; then
        env $env chroot $Box_Merged /bin/bash -l
    else
        env $env chroot $Box_Merged /bin/bash -l -c "$command"
    fi

    BuildUnmount || true

    trap EXIT
)

ExecInCoreChroot ()
(   # execute in subshell

    local environment="
    POGO_CHROOT=Core
    FORCE_UNSAFE_CONFIGURE=1
    MAKEFLAGS=-j8
    LC_ALL=en_US.UTF-8
    LANG=en_US.UTF-8
    LANGUAGE=en_US.UTF-8"

    _chroot_exec2 "$Core_Root:$Tools_Root:$PogoVolume:$Box_Root" "$environment" "${1-}"
)

ExecInToolsChroot ()
(   # execute in subshell

    local environment="
    POGO_CHROOT=Tools
    FORCE_UNSAFE_CONFIGURE=1
    MAKEFLAGS=-j8
    LC_ALL=POSIX"

    _chroot_exec2 "$Tools_Root:$Boots_Root:$PogoVolume:$Box_Root" "$environment" "${1-}"
)

ExecInBootsChroot ()
(   # execute in subshell

    local environment="
    POGO_CHROOT=Boots
    FORCE_UNSAFE_CONFIGURE=1
    MAKEFLAGS=-j8
    LC_ALL=POSIX
    LFS=$Current_Root
    LFS_TGT=x86_64-lfs-linux-gnu"

    _chroot_exec2 "$Box_Root:$PogoVolume:/" "$environment" "${1-}"
)

MakeCoreRootfs ()
{
    local rootfs=$Box_Root

    RootMakeDir 0775 LiFo
    RootMakeDir 0775 root
    RootMakeDir 0775 bin
    RootMakeDir 0775 etc
    RootMakeDir 1777 tmp
    RootMakeDir 0775 dev
    RootMakeDir 0775 proc
    RootMakeDir 0775 sys

    RootMakeDir 0775 run
    RootMakeDir 0775 run/lock

    RootMakeDir 0775 var
    RootMakeDir 0775 var/cache
    RootMakeDir 0775 var/lib
    RootMakeDir 0775 var/log
    RootMakeDir 1777 var/tmp

    RootSymLink bin/sh                  bash

    touch $rootfs/etc/hostname
    touch $rootfs/etc/hosts
    touch $rootfs/etc/resolv.conf

    cat > $rootfs/etc/passwd << "EOF"
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/dev/null:/bin/false
nobody:x:999:999:Unprivileged User:/dev/null:/bin/false
EOF

    cat > $rootfs/etc/group << "EOF"
root:x:0:
bin:x:1:daemon
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11:
video:x:12:
utmp:x:13:
usb:x:14:
cdrom:x:15:
adm:x:16:
input:x:24:
mail:x:34:
nogroup:x:99:
users:x:999:
EOF
}

MakeToolsRootfs ()
{
    local rootfs=$Box_Root

    RootMakeDir 0775 LiFo
    RootMakeDir 0775 root
    RootMakeDir 0775 bin
    RootMakeDir 0775 sbin
    RootMakeDir 0775 etc
    RootMakeDir 0775 lib
    RootMakeDir 0775 lib64
    RootMakeDir 1777 tmp
    RootMakeDir 1777 dev
    RootMakeDir 1777 proc
    RootMakeDir 1777 sys

    RootMakeDir 0775 run
    RootMakeDir 0775 run/lock

    RootMakeDir 0775 var
    RootMakeDir 0775 var/cache
    RootMakeDir 0775 var/lib
    RootMakeDir 0775 var/log
    RootMakeDir 1777 var/tmp

    RootMakeDir 0775 usr/bin
    RootMakeDir 0775 usr/sbin
    RootMakeDir 0775 usr/include
    RootMakeDir 0775 usr/lib
    RootMakeDir 0775 usr/lib/pkgconfig
    RootMakeDir 0775 usr/libexec
    RootMakeDir 0775 usr/share
    RootMakeDir 0775 usr/share/color
    RootMakeDir 0775 usr/share/dict
    RootMakeDir 0775 usr/share/doc
    RootMakeDir 0775 usr/share/info
    RootMakeDir 0775 usr/share/locale
    RootMakeDir 0775 usr/share/man
    RootMakeDir 0775 usr/share/misc
    RootMakeDir 0775 usr/share/terminfo
    RootMakeDir 0775 usr/share/zoneinfo
    RootMakeDir 0775 usr/share/man/man{1..8}

    RootSymLink bin/bash                /tools/bin/bash
    RootSymLink bin/sh                  bash
    RootSymLink bin/cat                 /tools/bin/cat
    RootSymLink bin/dd                  /tools/bin/dd
    RootSymLink bin/echo                /tools/bin/echo
    RootSymLink bin/ln                  /tools/bin/ln
    RootSymLink bin/pwd                 /tools/bin/pwd
    RootSymLink bin/rm                  /tools/bin/rm
    RootSymLink bin/stty                /tools/bin/stty

    RootSymLink usr/bin/install         /tools/bin/install
    RootSymLink usr/bin/perl            /tools/bin/perl
    RootSymLink usr/bin/env             /tools/bin/env

    RootSymLink usr/lib/libgcc_s.so     /tools/lib/libgcc_s.so
    RootSymLink usr/lib/libgcc_s.so.1   /tools/lib/libgcc_s.so.1

    RootSymLink usr/lib/libstdc++.a     /tools/lib/libstdc++.a
    RootSymLink usr/lib/libstdc++.so    /tools/lib/libstdc++.so
    RootSymLink usr/lib/libstdc++.so.6  /tools/lib/libstdc++.so.6

    touch $rootfs/etc/hostname
    touch $rootfs/etc/hosts
    touch $rootfs/etc/resolv.conf

    cat > $rootfs/etc/passwd << "EOF"
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/dev/null:/bin/false
nobody:x:99:99:Unprivileged User:/dev/null:/bin/false
EOF

    cat > $rootfs/etc/group << "EOF"
root:x:0:
bin:x:1:daemon
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11:
video:x:12:
utmp:x:13:
usb:x:14:
cdrom:x:15:
adm:x:16:
input:x:24:
mail:x:34:
nogroup:x:99:
users:x:999:
EOF
}

MakeBootsRootfs ()
{
    local rootfs=$Box_Root

    MakeDir $Current_Root/tools

    RootMakeDir 0775 bin
    RootSymLink bin/sh      bash
    RootSymLink tools       $Current_Root/tools
}

BuildUnmount ()
{
    local match=$Box_Top
    local mountpoint
    while mount | grep -q "${match}"; do
        mount | grep "${match}" | cut -f3 -d" " | sort | while read mountpoint; do
            if [[ -z $verbose ]]; then
                mountpoint --quiet ${mountpoint} &>/dev/null && umount --recursive ${mountpoint} &>/dev/null
            else
                mountpoint --quiet ${mountpoint} &>/dev/null && umount --verbose --recursive ${mountpoint} 2>&1
            fi
        done
    done

    true
}

_harvest_ListFiles () # bomFile
{
    local bomFile="$1"
    gawk -F'\t' -- '/^f/ { print $6 }' $bomFile 
}

_harvest_ListKnown () # bomFile
{ 
    local bomFile="$1"
    gawk -F'\t' -- '/^[dfl]/ { print $6 }' "$bomFile"
}

_harvest_ListUnknown () # bomFile
{ 
    local bomFile="$1"
    gawk -F'\t' -- '/^[dfl]/ { next } { print $0 }' "$bomFile"
}


_harvest_Validate () # bomFile
{
    local bomFile="$1"
    gawk -F'\t' -- '/^[dfl]\t/ { next } { print "=>"; print $0; exit 1; }' $bomFile || echo "unkown entry in bill of material"
}

_harvest_Strip () # bomFile topDir
{
    local bomFile="$1"
    local topDir="$2"
    cd $topDir

    _stripUnneeded ()
    {
        [[ -z $verbose ]] || echo strip --strip-unneeded $1
        strip --strip-unneeded $1
    }

    _stripDebug ()
    {
        [[ -z $verbose ]] || echo strip --strip-debug $1
        strip --strip-debug $1
    }

    local name type
    _harvest_ListFiles "$bomFile" | file --mime --files-from - | while IFS=$':' read name type; do
        case $type in
            *application/x-executable*)  _stripUnneeded $name ;;
            *application/x-sharedlib*)   _stripDebug $name ;;
            *application/x-object*)      _stripDebug $name ;;
            *application/x-archive*)     _stripDebug $name ;;
        esac
    done
}

_harvest_Archive ()
{
    local bomFile="$1"
    local topDir="$2"
    local archiveFile="$3"

    (
        cd $topDir
        _harvest_ListKnown "$bomFile" | \
        tar $verbose \
            --create \
            --no-recursion \
            --verbatim-files-from \
            --files-from=- \
            --auto-compress \
            --file "$archiveFile"
    )
}

_harvest_Rollout ()
{
    Pushd "$Current_Root"
    tar $verbose --extract --file="$Store_FilesFiles"
    Popd
}

CleanupLocale()
{
    :
}

_harvest_Bom () # bomFile topDir
{
    local bomFile="$1"
    local topDir="$2"
    local blackoutScript='
        $6 ~ /^tools\/share\/(info|man|doc)\// { next; }
        $6 ~ /^Data/ { next; }
        $6 ~ /^tmp/ { next; }
        $6 ~ /^bin$/ { next; }
        $6 ~ /^sbin$/ { next; }
        $6 ~ /^etc$/ { next; }
        $6 ~ /^lib$/ { next; }
        $6 ~ /^lib64$/ { next; }
        $6 ~ /^usr$/ { next; }
        $6 ~ /^usr\/bin$/ { next; }
        $6 ~ /^usr\/sbin$/ { next; }
        $6 ~ /^usr\/lib$/ { next; }
        $6 ~ /^usr\/libexec$/ { next; }
        $6 ~ /^usr\/lib\/charset.alias$/ { next; }
        $6 ~ /^usr\/lib\/pkgconfig$/ { next; }
        $6 ~ /^usr\/include$/ { next; }
        $6 ~ /^usr\/share$/ { next; }
        $6 ~ /^usr\/share\/locale$/ { next; }
        $6 ~ /^usr\/share\/doc$/ { next; }
        $6 ~ /^usr\/share\/info$/ { next; }
        $6 ~ /^usr\/share\/info\/dir$/ { next; }
        $6 ~ /^usr\/share\/man$/ { next; }
        $6 ~ /^usr\/share\/man\/man[1-8]$/ { next; }
        $6 ~ /^usr\/share\/misc$/ { next; }
        $6 ~ /^usr\/share\/aclocal$/ { next; }
        $6 ~ /^var$/ { next; }
        $6 ~ /^var\/cache$/ { next; }
        $6 ~ /^var\/lib$/ { next; }
        $6 ~ /^var\/tmp$/ { next; }
        $6 ~ /^etc\/ld.so.cache$/ { next; }
        $6 ~ /^var\/cache\// { next; }
        { print $0 }'

    (
        cd $topDir
        find . -mindepth 1 \( \
            -type l -printf '%y\t%M\t%4m\t%3n\t%10s\t%P\t%l\n' \
            -o      -printf '%y\t%M\t%4m\t%3n\t%10s\t%P\n' \)
    ) | gawk -- "$blackoutScript" >"$bomFile"
}

_build_Harvest ()
{
    Header "HARVEST $Current_Collection / $Recipe_Title"

    local topDir
    if [[ "$Current_Collection" == "Boots" ]]; then
        topDir="$Box_Changes$Current_Root"
    else
        topDir="$Box_Changes"
    fi
    local bomFile="$Store_FilesBom"
    local archiveFile="$Store_FilesFiles"

    declare -p topDir

    [[ -d "$topDir" ]] || InfoExit "nothing to harvest"

    if [[ -d $topDir/usr/lib ]]; then
        find $topDir/usr/lib -type f -name '*.la' -delete
    fi
    
    _harvest_Bom "$bomFile" "$topDir"
    _harvest_Validate "$bomFile"
    _harvest_Strip "$bomFile" "$topDir"
    _harvest_Bom "$bomFile" "$topDir"
    _harvest_Archive "$bomFile" "$topDir" "$archiveFile"
    cat $bomFile
}

Build_Harvest ()
{
    NeverInChroot

    _build_Enter "$@"
    _build_EnsureBuild

    _build_Harvest
}

Build_Rollout ()
{
    NeverInChroot

    _build_Enter "$@"

    Header "ROLLOUT $Current_Collection / $Recipe_Title"

    _harvest_Rollout
}
